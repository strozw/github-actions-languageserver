import { isMapping } from "@actions/workflow-parser";
import { isActionStep } from "@actions/workflow-parser/model/type-guards";
import { DiagnosticSeverity } from "vscode-languageserver-types";
import { parseActionReference } from "./action";
import { mapRange } from "./utils/range";
export async function validateAction(diagnostics, stepToken, step, config) {
    if (!isMapping(stepToken) || !step || !isActionStep(step) || !config?.actionsMetadataProvider) {
        return;
    }
    const action = parseActionReference(step.uses.value);
    if (!action) {
        return;
    }
    const actionMetadata = await config.actionsMetadataProvider.fetchActionMetadata(action);
    if (actionMetadata === undefined) {
        diagnostics.push({
            severity: DiagnosticSeverity.Error,
            range: mapRange(step.uses.range),
            message: `Unable to resolve action \`${step.uses.value}\`, repository or version not found`
        });
        return;
    }
    let withKey;
    let withToken;
    for (const { key, value } of stepToken) {
        if (key.toString() === "with") {
            withKey = key;
            withToken = value;
            break;
        }
    }
    const stepInputs = new Map();
    if (withToken && isMapping(withToken)) {
        for (const { key } of withToken) {
            stepInputs.set(key.toString(), key);
        }
    }
    const actionInputs = actionMetadata.inputs;
    if (actionInputs === undefined) {
        return;
    }
    for (const [input, inputToken] of stepInputs) {
        if (!actionInputs[input]) {
            diagnostics.push({
                severity: DiagnosticSeverity.Error,
                range: mapRange(inputToken.range),
                message: `Invalid action input '${input}'`
            });
        }
        const deprecationMessage = actionInputs[input]?.deprecationMessage;
        if (deprecationMessage) {
            diagnostics.push({
                severity: DiagnosticSeverity.Warning,
                range: mapRange(inputToken.range),
                message: deprecationMessage
            });
        }
    }
    const missingRequiredInputs = Object.entries(actionInputs).filter(([inputName, input]) => input.required && !stepInputs.has(inputName) && input.default === undefined);
    if (missingRequiredInputs.length > 0) {
        const message = missingRequiredInputs.length === 1
            ? `Missing required input \`${missingRequiredInputs[0][0]}\``
            : `Missing required inputs: ${missingRequiredInputs.map(input => `\`${input[0]}\``).join(", ")}`;
        diagnostics.push({
            severity: DiagnosticSeverity.Error,
            range: mapRange((withKey || stepToken).range),
            message: message
        });
    }
}
//# sourceMappingURL=validate-action.js.map