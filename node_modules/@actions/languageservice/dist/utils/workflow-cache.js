import { convertWorkflowTemplate, parseWorkflow } from "@actions/workflow-parser";
import { nullTrace } from "../nulltrace";
const parsedWorkflowCache = new Map();
const workflowTemplateCache = new Map();
export function clearCacheEntry(uri) {
    parsedWorkflowCache.delete(uri);
    parsedWorkflowCache.delete(workflowKey(uri, true));
    workflowTemplateCache.delete(uri);
    workflowTemplateCache.delete(workflowKey(uri, true));
}
export function clearCache() {
    parsedWorkflowCache.clear();
    workflowTemplateCache.clear();
}
/**
 * Parses a workflow file and caches the result
 * @param transformed Indicates whether the workflow has been transformed before parsing
 * @returns the {@link ParseWorkflowResult}
 */
export function fetchOrParseWorkflow(file, uri, transformed = false) {
    const key = workflowKey(uri, transformed);
    const cachedResult = parsedWorkflowCache.get(key);
    if (cachedResult) {
        return cachedResult;
    }
    const result = parseWorkflow(file, nullTrace);
    parsedWorkflowCache.set(key, result);
    return result;
}
/**
 * Converts a workflow template and caches the result
 * @param transformed Indicates whether the workflow has been transformed before parsing
 * @returns the converted {@link WorkflowTemplate}
 */
export async function fetchOrConvertWorkflowTemplate(context, template, uri, config, options, transformed = false) {
    const key = workflowKey(uri, transformed);
    const cachedTemplate = workflowTemplateCache.get(key);
    if (cachedTemplate) {
        return cachedTemplate;
    }
    const workflowTemplate = await convertWorkflowTemplate(context, template, config?.fileProvider, options);
    workflowTemplateCache.set(key, workflowTemplate);
    return workflowTemplate;
}
// Use a separate cache key for transformed workflows
function workflowKey(uri, transformed) {
    if (transformed) {
        return `transformed-${uri}`;
    }
    return uri;
}
//# sourceMappingURL=workflow-cache.js.map