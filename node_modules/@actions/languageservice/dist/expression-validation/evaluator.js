import { Evaluator, ExpressionEvaluationError, data } from "@actions/expressions";
import { TokenType } from "@actions/expressions/lexer";
import { falsy, truthy } from "@actions/expressions/result";
import { AccessError } from "./error-dictionary";
export class ValidationEvaluator extends Evaluator {
    constructor() {
        super(...arguments);
        this.errors = [];
    }
    validate() {
        super.evaluate();
    }
    eval(n) {
        try {
            return super.eval(n);
        }
        catch (e) {
            // Record error
            if (e instanceof AccessError) {
                this.errors.push({
                    message: `Context access might be invalid: ${e.keyName}`,
                    severity: "warning"
                });
            }
            else if (e instanceof ExpressionEvaluationError) {
                this.errors.push({
                    message: `Expression might be invalid: ${e.message}`,
                    severity: "error"
                });
            }
        }
        // Return null but continue with the validation
        return new data.Null();
    }
    visitLogical(logical) {
        let result;
        for (const arg of logical.args) {
            const r = this.eval(arg);
            // Simulate short-circuit behavior but continue to evalute all arguments for validation purposes
            if (!result &&
                ((logical.operator.type === TokenType.AND && falsy(r)) || (logical.operator.type === TokenType.OR && truthy(r)))) {
                result = r;
            }
        }
        // result is always assigned before we return here
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return result;
    }
}
//# sourceMappingURL=evaluator.js.map