import { BooleanDefinition } from "@actions/workflow-parser/templates/schema/boolean-definition";
import { DefinitionType } from "@actions/workflow-parser/templates/schema/definition-type";
import { MappingDefinition } from "@actions/workflow-parser/templates/schema/mapping-definition";
import { OneOfDefinition } from "@actions/workflow-parser/templates/schema/one-of-definition";
import { SequenceDefinition } from "@actions/workflow-parser/templates/schema/sequence-definition";
import { StringDefinition } from "@actions/workflow-parser/templates/schema/string-definition";
import { getWorkflowSchema } from "@actions/workflow-parser/workflows/workflow-schema";
import { stringsToValues } from "./strings-to-values";
export var DefinitionValueMode;
(function (DefinitionValueMode) {
    /**
     * We're getting completion options for a parent token
     * foo:
     *   ba|
     */
    DefinitionValueMode[DefinitionValueMode["Parent"] = 0] = "Parent";
    /**
     * We're getting completion options for a key token. For example:
     * foo: |
     */
    DefinitionValueMode[DefinitionValueMode["Key"] = 1] = "Key";
})(DefinitionValueMode || (DefinitionValueMode = {}));
export function definitionValues(def, indentation, mode) {
    const schema = getWorkflowSchema();
    if (def instanceof MappingDefinition) {
        return mappingValues(def, schema.definitions, indentation, mode);
    }
    if (def instanceof OneOfDefinition) {
        return oneOfValues(def, schema.definitions, indentation, mode);
    }
    if (def instanceof BooleanDefinition) {
        return stringsToValues(["true", "false"]);
    }
    if (def instanceof StringDefinition && def.constant) {
        return [
            {
                label: def.constant,
                description: def.description
            }
        ];
    }
    if (def instanceof SequenceDefinition) {
        const itemDef = schema.getDefinition(def.itemType);
        if (itemDef) {
            return definitionValues(itemDef, indentation, mode);
        }
    }
    return [];
}
function mappingValues(mappingDefinition, definitions, indentation, mode) {
    const properties = [];
    for (const [key, value] of Object.entries(mappingDefinition.properties)) {
        let insertText;
        let description;
        if (value.type) {
            const typeDef = definitions[value.type];
            description = typeDef?.description;
            if (typeDef) {
                switch (typeDef.definitionType) {
                    case DefinitionType.Sequence:
                        if (mode == DefinitionValueMode.Key) {
                            insertText = `\n${indentation}${key}:\n${indentation}${indentation}- `;
                        }
                        else {
                            insertText = `${key}:\n${indentation}- `;
                        }
                        break;
                    case DefinitionType.Mapping:
                        if (mode == DefinitionValueMode.Key) {
                            insertText = `\n${indentation}${key}:\n${indentation}${indentation}`;
                        }
                        else {
                            insertText = `${key}:\n${indentation}`;
                        }
                        break;
                    case DefinitionType.OneOf:
                        if (mode == DefinitionValueMode.Parent) {
                            insertText = `${key}: `;
                        }
                        else {
                            // No special insertText in this case
                        }
                        break;
                    case DefinitionType.String:
                    case DefinitionType.Boolean:
                        if (mode == DefinitionValueMode.Key) {
                            insertText = `\n${indentation}${key}: `;
                        }
                        else {
                            insertText = `${key}: `;
                        }
                        break;
                    default:
                        insertText = `${key}: `;
                }
            }
        }
        properties.push({
            label: key,
            description,
            insertText
        });
    }
    return properties;
}
function oneOfValues(oneOfDefinition, definitions, indentation, mode) {
    const values = [];
    for (const key of oneOfDefinition.oneOf) {
        values.push(...definitionValues(definitions[key], indentation, mode));
    }
    return distinctValues(values);
}
function distinctValues(values) {
    const map = new Map();
    for (const value of values) {
        map.set(value.label, value);
    }
    return Array.from(map.values());
}
//# sourceMappingURL=definition.js.map