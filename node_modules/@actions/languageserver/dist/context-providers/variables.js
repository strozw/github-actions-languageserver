import { data, DescriptionDictionary } from "@actions/expressions";
import { StringData } from "@actions/expressions/data/index";
import { log, warn } from "@actions/languageservice/log";
import { isMapping, isString } from "@actions/workflow-parser";
import { RequestError } from "@octokit/request-error";
import { errorStatus } from "../utils/error";
import { getRepoPermission } from "../utils/repo-permission";
export async function getVariables(workflowContext, octokit, cache, repo, defaultContext) {
    const permission = await getRepoPermission(octokit, cache, repo);
    if (permission === "none") {
        const secretsContext = defaultContext || new DescriptionDictionary();
        secretsContext.complete = false;
        return secretsContext;
    }
    let environmentName;
    if (workflowContext?.job?.environment) {
        if (isString(workflowContext.job.environment)) {
            environmentName = workflowContext.job.environment.value;
        }
        else if (isMapping(workflowContext.job.environment)) {
            for (const x of workflowContext.job.environment) {
                if (isString(x.key) && x.key.value === "name") {
                    if (isString(x.value)) {
                        environmentName = x.value.value;
                    }
                    break;
                }
            }
        }
    }
    const variablesContext = defaultContext || new DescriptionDictionary();
    try {
        const variables = await getRemoteVariables(octokit, cache, repo, environmentName);
        // Build combined map of variables
        const variablesMap = new Map();
        variables.organizationVariables.forEach(variable => variablesMap.set(variable.key.toLowerCase(), {
            key: variable.key,
            value: new data.StringData(variable.value.coerceString()),
            description: `${variable.value.coerceString()} - Organization variable`
        }));
        // Override org variables with repo variables
        variables.repoVariables.forEach(variable => variablesMap.set(variable.key.toLowerCase(), {
            key: variable.key,
            value: new data.StringData(variable.value.coerceString()),
            description: `${variable.value.coerceString()} - Repository variable`
        }));
        // Override repo variables with environment veriables (if defined)
        variables.environmentVariables.forEach(variable => variablesMap.set(variable.key.toLowerCase(), {
            key: variable.key,
            value: new data.StringData(variable.value.coerceString()),
            description: `${variable.value.coerceString()} - Variable for environment \`${environmentName || ""}\``
        }));
        // Sort variables by key and add to context
        Array.from(variablesMap.values())
            .sort((a, b) => a.key.localeCompare(b.key))
            .forEach(variable => variablesContext?.add(variable.key, variable.value, variable.description));
        return variablesContext;
    }
    catch (e) {
        if (!(e instanceof RequestError))
            throw e;
        if (e.name == "HttpError" && e.status == 404) {
            log("Failure to request variables. Ignore if you're using GitHub Enterprise Server below version 3.8");
            return variablesContext;
        }
        else
            throw e;
    }
}
export async function getRemoteVariables(octokit, cache, repo, environmentName) {
    // Repo variables
    return {
        repoVariables: await cache.get(`${repo.owner}/${repo.name}/vars`, undefined, () => fetchVariables(octokit, repo.owner, repo.name)),
        environmentVariables: (environmentName &&
            (await cache.get(`${repo.owner}/${repo.name}/vars/environment/${environmentName}`, undefined, () => fetchEnvironmentVariables(octokit, repo.id, environmentName)))) ||
            [],
        organizationVariables: await cache.get(`${repo.owner}/vars`, undefined, () => fetchOrganizationVariables(octokit, repo))
    };
}
async function fetchVariables(octokit, owner, name) {
    try {
        return await octokit.paginate(octokit.actions.listRepoVariables, {
            owner: owner,
            repo: name,
            per_page: 100
        }, response => response.data.map(variable => {
            return { key: variable.name, value: new StringData(variable.value) };
        }));
    }
    catch (e) {
        console.log("Failure to retrieve variables: ", e);
        throw e;
    }
}
async function fetchEnvironmentVariables(octokit, repositoryId, environmentName) {
    try {
        return await octokit.paginate(octokit.actions.listEnvironmentVariables, {
            repository_id: repositoryId,
            environment_name: environmentName,
            per_page: 100
        }, response => response.data.map(variable => {
            return { key: variable.name, value: new StringData(variable.value) };
        }));
    }
    catch (e) {
        if (errorStatus(e) === 404) {
            warn(`Environment ${environmentName} not found`);
            return [];
        }
        console.log("Failure to retrieve environment variables: ", e);
        throw e;
    }
}
async function fetchOrganizationVariables(octokit, repo) {
    if (!repo.organizationOwned) {
        return [];
    }
    try {
        const variables = await octokit.paginate("GET /repos/{owner}/{repo}/actions/organization-variables", {
            owner: repo.owner,
            repo: repo.name,
            per_page: 100
        });
        return variables.map(variable => {
            return { key: variable.name, value: new StringData(variable.value) };
        });
    }
    catch (e) {
        console.log("Failure to retrieve organization variables: ", e);
        throw e;
    }
}
//# sourceMappingURL=variables.js.map